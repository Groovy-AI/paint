<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>paint.a</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body {
    margin: 0;
    height: 100vh;
    display: flex;
    flex-direction: column;
    font-family: system-ui, Arial, sans-serif;
    background: white;
}

header {
    background: #1f1f1f;
    color: white;
    padding: 12px;
    text-align: center;
    font-size: 18px;
    font-weight: 600;
}

#toolbar {
    background: #2b2b2b;
    padding: 8px;
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    align-items: center;
}

#toolbar label {
    color: #ccc;
    font-size: 13px;
}

button, select, input {
    background: #3a3a3a;
    color: white;
    border: none;
    padding: 5px 8px;
    border-radius: 4px;
    font-size: 13px;
}

button:hover {
    background: #555;
}

#canvasWrapper {
    flex: 1;
    overflow: hidden;
    background: white;
}

#canvasContainer {
    position: relative;
    width: 100%;
    height: 100%;
    transform-origin: 0 0;
}

canvas {
    position: absolute;
    inset: 0;
    touch-action: none;
    cursor: crosshair;
}
</style>
</head>

<body>

<header>paint.a</header>

<div id="toolbar">
    <label>Tool</label>
    <select id="tool">
        <option value="brush">Brush</option>
        <option value="eraser">Eraser</option>
        <option value="fill">Bucket</option>
        <option value="screenFill">Screen Fill</option>
    </select>

    <label>Color</label>
    <input type="color" id="color" value="#000000">

    <label>Size</label>
    <input type="range" id="size" min="1" max="80" value="6">

    <label>Opacity</label>
    <input type="range" id="opacity" min="0" max="1" step="0.01" value="1">

    <label>Preset</label>
    <select id="presetSelect"></select>
    <button id="savePreset">Save Preset</button>

    <button id="undo">Undo</button>
    <button id="redo">Redo</button>

    <label>Layer</label>
    <select id="layerSelect"></select>

    <label>Layer Opacity</label>
    <input type="range" id="layerOpacity" min="0" max="1" step="0.01" value="1">

    <button id="toggleLayer">Hide</button>
    <button id="addLayer">Add</button>

    <label>Zoom</label>
    <input type="range" id="zoom" min="0.5" max="3" step="0.1" value="1">

    <button id="saveProject">Save</button>
    <button id="loadProject">Load</button>
    <input type="file" id="fileInput" hidden>
</div>

<div id="canvasWrapper">
    <div id="canvasContainer"></div>
</div>

<script>
const container = document.getElementById("canvasContainer");
const layerSelect = document.getElementById("layerSelect");
const presetSelect = document.getElementById("presetSelect");

let layers = [];
let activeLayer = 0;
let drawing = false;

let tool = document.getElementById("tool").value;
let color = document.getElementById("color").value;
let size = document.getElementById("size").value;
let opacity = document.getElementById("opacity").value;
let zoom = 1;

let presets = [];
let undoStack = [];
let redoStack = [];

document.getElementById("tool").onchange = e => tool = e.target.value;
document.getElementById("color").oninput = e => color = e.target.value;
document.getElementById("size").oninput = e => size = e.target.value;
document.getElementById("opacity").oninput = e => opacity = e.target.value;

document.getElementById("zoom").oninput = e => {
    zoom = e.target.value;
    container.style.transform = `scale(${zoom})`;
};

document.getElementById("undo").onclick = undo;
document.getElementById("redo").onclick = redo;
document.getElementById("addLayer").onclick = addLayer;
document.getElementById("toggleLayer").onclick = toggleLayer;
document.getElementById("savePreset").onclick = savePreset;

document.getElementById("saveProject").onclick = saveProject;
document.getElementById("loadProject").onclick = () => fileInput.click();
document.getElementById("fileInput").onchange = loadProject;

layerSelect.onchange = () => activeLayer = Number(layerSelect.value);

document.getElementById("layerOpacity").oninput = e => {
    const l = layers[activeLayer];
    l.opacity = e.target.value;
    l.canvas.style.opacity = e.target.value;
};

function addLayer() {
    const canvas = document.createElement("canvas");
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
    container.appendChild(canvas);

    layers.push({
        canvas,
        ctx: canvas.getContext("2d"),
        visible: true,
        opacity: 1
    });

    activeLayer = layers.length - 1;
    updateLayersUI();
}

function updateLayersUI() {
    layerSelect.innerHTML = "";
    layers.forEach((_, i) => {
        const o = document.createElement("option");
        o.value = i;
        o.textContent = `Layer ${i + 1}`;
        if (i === activeLayer) o.selected = true;
        layerSelect.appendChild(o);
    });
}

function saveState() {
    undoStack.push(container.innerHTML);
    redoStack.length = 0;
}

function undo() {
    if (!undoStack.length) return;
    redoStack.push(container.innerHTML);
    container.innerHTML = undoStack.pop();
    rebuildLayers();
}

function redo() {
    if (!redoStack.length) return;
    undoStack.push(container.innerHTML);
    container.innerHTML = redoStack.pop();
    rebuildLayers();
}

function rebuildLayers() {
    layers = [...container.querySelectorAll("canvas")].map(c => ({
        canvas: c,
        ctx: c.getContext("2d"),
        visible: c.style.display !== "none",
        opacity: c.style.opacity || 1
    }));
}

container.addEventListener("pointerdown", e => {
    const l = layers[activeLayer];
    if (!l) return;

    saveState();

    if (tool === "fill") {
        floodFill(l.ctx, Math.floor(e.offsetX), Math.floor(e.offsetY));
        return;
    }

    if (tool === "screenFill") {
        l.ctx.globalAlpha = opacity;
        l.ctx.fillStyle = color;
        l.ctx.fillRect(0, 0, l.canvas.width, l.canvas.height);
        return;
    }

    drawing = true;
    l.ctx.beginPath();
    l.ctx.moveTo(e.offsetX, e.offsetY);
});

container.addEventListener("pointermove", e => {
    if (!drawing) return;

    const ctx = layers[activeLayer].ctx;
    ctx.lineWidth = size;
    ctx.lineCap = "round";
    ctx.globalAlpha = opacity;
    ctx.globalCompositeOperation = tool === "eraser" ? "destination-out" : "source-over";
    if (tool !== "eraser") ctx.strokeStyle = color;

    ctx.lineTo(e.offsetX, e.offsetY);
    ctx.stroke();
});

container.addEventListener("pointerup", () => drawing = false);
container.addEventListener("pointerleave", () => drawing = false);

/* BUCKET FILL */
function floodFill(ctx, x, y) {
    const canvas = ctx.canvas;
    const w = canvas.width;
    const h = canvas.height;

    const img = ctx.getImageData(0, 0, w, h);
    const data = img.data;

    const index = (y * w + x) * 4;
    const target = data.slice(index, index + 4);
    const fill = hexToRgba(color, opacity);

    if (colorsMatch(target, fill)) return;

    const stack = [[x, y]];

    while (stack.length) {
        const [cx, cy] = stack.pop();
        if (cx < 0 || cy < 0 || cx >= w || cy >= h) continue;

        const i = (cy * w + cx) * 4;
        if (!colorsMatch(data.slice(i, i + 4), target)) continue;

        data[i] = fill[0];
        data[i + 1] = fill[1];
        data[i + 2] = fill[2];
        data[i + 3] = fill[3];

        stack.push([cx + 1, cy]);
        stack.push([cx - 1, cy]);
        stack.push([cx, cy + 1]);
        stack.push([cx, cy - 1]);
    }

    ctx.putImageData(img, 0, 0);
}

function colorsMatch(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

function hexToRgba(hex, a) {
    return [
        parseInt(hex.slice(1, 3), 16),
        parseInt(hex.slice(3, 5), 16),
        parseInt(hex.slice(5, 7), 16),
        Math.floor(a * 255)
    ];
}

/* PRESETS */
function savePreset() {
    presets.push({ tool, color, size, opacity });
    presetSelect.innerHTML = presets.map((_, i) => `<option value="${i}">Preset ${i + 1}</option>`).join("");
}

presetSelect.onchange = () => {
    const p = presets[presetSelect.value];
    if (!p) return;
    tool = p.tool;
    color = p.color;
    size = p.size;
    opacity = p.opacity;
    document.getElementById("tool").value = tool;
    document.getElementById("color").value = color;
    document.getElementById("size").value = size;
    document.getElementById("opacity").value = opacity;
};

/* SAVE / LOAD */
function saveProject() {
    const data = {
        presets,
        layers: layers.map(l => ({
            image: l.canvas.toDataURL(),
            opacity: l.opacity,
            visible: l.visible
        }))
    };

    const blob = new Blob([JSON.stringify(data)], { type: "application/json" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "paint.a.json";
    a.click();
}

function loadProject(e) {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = () => {
        const data = JSON.parse(reader.result);
        container.innerHTML = "";
        layers = [];

        data.layers.forEach(l => {
            const c = document.createElement("canvas");
            c.width = container.clientWidth;
            c.height = container.clientHeight;
            c.style.opacity = l.opacity;
            c.style.display = l.visible ? "block" : "none";
            const ctx = c.getContext("2d");

            const img = new Image();
            img.onload = () => ctx.drawImage(img, 0, 0);
            img.src = l.image;

            container.appendChild(c);
            layers.push({ canvas: c, ctx, opacity: l.opacity, visible: l.visible });
        });

        presets = data.presets || [];
        presetSelect.innerHTML = presets.map((_, i) => `<option value="${i}">Preset ${i + 1}</option>`).join("");
        updateLayersUI();
    };
    reader.readAsText(file);
}

function toggleLayer() {
    const l = layers[activeLayer];
    l.visible = !l.visible;
    l.canvas.style.display = l.visible ? "block" : "none";
}

/* START */
addLayer();
</script>

</body>
</html>
